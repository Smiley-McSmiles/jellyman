#!/bin/bash
jellymanVersion="v1.8.3"
logDir=/opt/jellyfin/log
logFile=$logDir/jellyman.log
sourceFile="/opt/jellyfin/config/jellyman.conf"
source /usr/bin/jellyman-functions
helpList="
> Jellyman - The Jellyfin Manager $jellymanVersion
- Created by WOOSAH (Smiley McSmiles)

> Syntax: jellyman -[COMMAND] [PARAMETER]
> COMMANDS:
-b,   --backup               [DIRECTORY] Input directory to output backup archive.
-ba,  --backup-auto          Perform an automatic backup.
-bu,  --backup-utility       Start the automatic backup utility.
-d,   --disable              Disable Jellyfin on System Start.
-e,   --enable               Enable Jellyfin on System Start.
-h,   --help                 Print this Help.
-i,   --import               [FILE.tar - optional] Input file to Import jellyfin-backup.tar.
-p,   --permissions          [DIRECTORY - optional] Reset the permissions of Jellyfin's Media Library or supplied directory.
-r,   --restart              Restart Jellyfin.
-s,   --start                Start Jellyfin.
-S,   --stop                 Stop Jellyfin.
-t,   --status               Status of Jellyfin.
-u,   --update-jellyfin      [URL - optional] Downloads and updates the current stable or supplied Jellyfin version.
-U,   --update-jellyman      Update Jellyman - The Jellyfin Manager.
-ub,  --update-beta          Update Jellyfin to the most recent Beta.
-ls,  --library-scan         Tell Jellyfin to scan your media library.
-v,   --version              Get the current installed version of Jellyfin.
-vd,  --version-download     Download an available Jellyfin version from the stable repository.
-vs,  --version-switch       Switch Jellyfin version for another previously installed version.
-vr,  --version-remove       Remove a Jellyfin version.
-vl   --view-log             Choose from a list of logs to view.
-rc,  --recertify            Removes old https certifications and creates new ones for the next 365 days.
-rn,  --rename               Batch renaming script for TV shows.
-cp,  --change-http          Change Jellyfins http network port - Default = 8096.
-cps, --change-https         Change Jellyfins https network port - Default = 8920.
-ik,  --import-key           Import an API key.
-md,  --media-directory      Change the Media Directory for Jellyman.
-tc,  --transcode            Transcode a file/directory with a GB per hour filter (1.5GB is recommended).
-tcp, --transcode-progress   View progress of the Transcode.
-tcs, --transcode-stop       Stop the current transcode process.
-X,   --uninstall            Uninstall Jellyfin and Jellyman Completely.

> To browse Jellyfin archives please use the link below.
 - https://repo.jellyfin.org/files/server/linux/stable/

> EXAMPLE:
- To stop jellyfin, disable on startup, and then get status of the jellyfin service:
	├── sudo jellyman --stop --disable --status
	└── sudo jellyman -S -d -t
"

###############################################################################
# FUNCTIONS                                                                   #
###############################################################################

Backup()
{
	HasSudo
	source $sourceFile
	# Backup /opt/jellyfin to passed directory
	backupDirectory="$1"
	tarPath=
	_date=$(date +%m-%d-%Y-%H:%M)
	fileName=jellyfin-backup-$_date.tar
	if [[ ! -d /opt/jellyfin/backup ]]; then
		mkdir /opt/jellyfin/backup
	fi
	cp /etc/jellyfin.conf /opt/jellyfin/backup/
	cp $jellyfinServiceLocation/jellyfin* /opt/jellyfin/backup/
	
	if [[ $(echo "${backupDirectory: -1}") == "/" ]]; then
		tarPath="$backupDirectory$fileName"
	else
		tarPath="$backupDirectory/$fileName"
	fi
	Log "BACKUP | Initiating backup to $tarPath" $logFile

	echo "> $tarPath"
	echo "> Running backup, this may take some time..."
	time tar cf "$tarPath" /opt/jellyfin
	USER1=$(stat -c '%U' "$backupDirectory")
	chown -f $USER1:$USER1 "$tarPath"
	chmod -f 770 "$tarPath"
	echo
	echo "+--------------------------------------------------------+"
	echo "|        To Import on your next setup, simply run:       |"
	echo "|  git clone https://github.com/Smiley-McSmiles/jellyman |"
	echo "|                       cd jellyman                      |"
	echo "|                   chmod ug+x setup.sh                  |"
	echo "|           sudo ./setup.sh and choose option 3          |"
	echo "+--------------------------------------------------------+"
	echo
	echo "> Your backup is:"
	tarSize=$(du -h "$tarPath")
	echo "> Size: $tarSize"
	return 0
	exit
}

BackupAuto()
{
	HasSudo
	source $sourceFile
	if [[ ! -n $backupDir ]]; then
		Log "ERROR | BACKUP-AUTO | AUTO-BACKUPS HAVE NOT BEEN SETUP." $logFile
		echo "> ERROR: AUTO-BACKUPS HAVE NOT BEEN SETUP. PLEASE RUN 'jellyman -bu'"
		exit
	else
		jellyman -b "$backupDir"

		tarList=$(ls -1 "$backupDir"/jellyfin-backup*.tar)
		newestTar=$(echo "$tarList" | tail -n 1)
		oldestTar=$(echo "$tarList" | head -n 1)
		tarCount=$(echo "$tarList" | wc -l)

		while [[ $tarCount -gt $maxBackupNumber ]]; do
			Log "BACKUP-AUTO | More than $maxBackupNumber, removing $oldestTar" $logFile
			echo "> There are $tarCount backups."
			echo "> Since there are more than $maxBackupNumber backups..."
			echo "> Jellyman is removing $oldestTar"
			# echo "> NewBackup=$newestTar"
			rm -f "$oldestTar"
			tarList=$(ls -1 "$backupDir"/jellyfin-backup*.tar)
			newestTar=$(echo "$tarList" | tail -n 1)
			oldestTar=$(echo "$tarList" | head -n 1)
			tarCount=$(echo "$tarList" | wc -l)
		done
	fi
}

BackupUtility()
{
	HasSudo
	while true; do
		clear
		optionNumber=
		autoBackupSwitch=
		source $sourceFile
		
		if [[ ! -d $backupDir ]]; then
			PromptUser dir "> Please enter your desired directory for backup archives"
			backupDir="$promptResult"
			PromptUser num "> Please enter your desired maximum number of backup archives" 1 20 "1-20"
			maxBackupNumber=$promptResult
			systemctl enable --now jellyfin-backup.timer
			SetVar backupDir "$backupDir" "$sourceFile" str
			SetVar maxBackupNumber $maxBackupNumber "$sourceFile" str
			SetVar autoBackups true "$sourceFile" sNewertr
			SetVar backupFrequency "weekly" "$sourceFile"
			Log "BACKUP-UTILITY | Setup BackupUtility at $backupDir max of $maxBackupNumber done weekly" $logFile
		fi
		
		source $sourceFile
		
		if $autoBackups; then
			autoBackupSwitch="ON"
		else
			autoBackupSwitch="OFF"
		fi
		echo
		echo "> Automatic backups are $autoBackupSwitch"
		echo
		echo "> 1. Enable automatic backups"
		echo "> 2. Disable automatic backups"
		echo "> 3. Change backup folder"
		echo "> 4. Change max backups [ $maxBackupNumber ]"
		echo "> 5. Change frequency of backups [ $backupFrequency ]"
		echo "> 6. Create a jellyfin-backup.tar archive"
		echo "> 7. EXIT"
		echo
		PromptUser num "> Please select the number corresponding with the option you want to select." 1 7 "1-7"
		optionNumber=$promptResult
		echo
		case $optionNumber in
			"1")
				# enable auto-backups
				systemctl enable --now jellyfin-backup.timer
				SetVar autoBackups true "$sourceFile" str
				Log "BACKUP-UTILITY | Automatic backups enabled" $logFile
				;;
			"2")
				# disable auto-backups
				systemctl disable --now jellyfin-backup.timer
				SetVar autoBackups false "$sourceFile" str
				Log "BACKUP-UTILITY | Automatic backups disabled" $logFile
				;;
			"3")
				# change backup folder
				if [[ -n $backupDir ]]; then
					echo "> Current directory for backups is $backupDir"
				fi
				PromptUser dir "> Please enter your desired directory for backup archives"
				backupDir="$promptResult"
				SetVar "backupDir" "$backupDir" "$sourceFile"
				Log "BACKUP-UTILITY | Automatic backup location changed to $backupDir" $logFile
				;;
			"4")
				# change max backups
				if [[ -n $maxBackupNumber ]]; then
					echo "> Current maximum backups allowed is $maxBackupNumber"
				fi
				PromptUser num "> Please enter your desired maximum number of backup archives" 1 50 "1-50"
				maxBackupNumber=$promptResult
				SetVar maxBackupNumber "$maxBackupNumber" "$sourceFile"
				Log "BACKUP-UTILITY | Max automatic backups changed to $maxBackupNumber " $logFile
				;;
			"5")
				# change frequency of backups
				echo "> Automatic backups will be done on a $backupFrequency basis."
				echo
				echo "> 1. Daily backups"
				echo "> 2. Weekly backups"
				echo "> 3. Monthly backups"
				echo
				PromptUser num "> Please select the number corresponding with the option you want to select." 1 3 "1-3"
				_optionNumber=$promptResult
				echo
				jellyfinBackupTimer=/usr/lib/systemd/system/jellyfin-backup.timer
				case $_optionNumber in
					"1")
						SetVar backupFrequency "daily" "$sourceFile"
						sed -i "s|OnCalendar.*|OnCalendar=*-*-* 01:00:00|g" $jellyfinBackupTimer
						echo "> Backups will now be created every day at 1:00 AM"
						read -p "> Press ENTER to exit" ENTER
						Log "BACKUP-UTILITY | Frequency of automatic backups changed to daily" $logFile
						;;
					"2")
						SetVar backupFrequency "weekly" "$sourceFile"
						sed -i "s|OnCalendar.*|OnCalendar=Sun *-*-* 01:00:00|g" $jellyfinBackupTimer
						echo "> Backups will now be created every Sunday at 1:00 AM"
						read -p "> Press ENTER to exit" ENTER
						Log "BACKUP-UTILITY | Frequency of automatic backups changed to weekly" $logFile
						;;
					"3")
						SetVar backupFrequency "monthly" "$sourceFile"
						sed -i "s|OnCalendar.*|OnCalendar=*-*-01 01:00:00|g" $jellyfinBackupTimer
						echo "> Backups will now be created on the 1st of every month at 1:00 AM"
						read -p "> Press ENTER to exit" ENTER
						Log "BACKUP-UTILITY | Frequency of automatic backups changed to monthly" $logFile
						;;
				esac
				systemctl daemon-reload
				systemctl restart jellyfin-backup.timer
				;;
			"6")
				jellyman -ba
				exit
				;;
			"7")
				exit
				;;
		esac
	done
}

IsJellyfinSetup()
{
	if [ -f "/opt/jellyfin/config/network.xml" ]; then
		Log "IS-JELLYFIN-SETUP | Checked if Jellyfin is setup, and it is" $logFile
		return 0
	else
		Log "ERROR | IS-JELLYFIN-SETUP | /opt/jellyfin/config/network.xml NOT FOUND!" $logFile
		echo "+--------------------------------------------------------------+"
		echo "|                        ***WARNING***                         |"
		echo "|             JELLYFIN DID NOT GET SET UP PROPERLY!            |"
		echo "|        NO /opt/jellyfin/config/network.xml FILE FOUND        |"
		echo "|  This is likely due to not completing the first time setup.  |"
		echo "|     Navigate to http://localhost:8096/ to complete setup     |"
		echo "+--------------------------------------------------------------+"
		return 1
	fi
}

isInstalledVersion()
{
	source $sourceFile
	jellyfinVersionToDownload=$1

	if [[ $jellyfinVersionToDownload == $currentVersion ]]; then
		Log "ERROR | IS-INSTALLED-VERSION | $jellyfinVersionToDownload = $currentVersion" $logFile
		echo "> ERROR: That version of Jellyfin is already installed."
		echo "> Current Jellyfin version installed: $currentVersion"
		return 0
	else
		echo "> Newer Jellyfin version found..."
		return 1
	fi
}

isDownloadedVersion()
{
	jellyfinVersionToDownload=$1
	
	if [[ -d /opt/jellyfin/$jellyfinVersionToDownload ]]; then
		Log "ERROR | IS-DOWNLOADED-VERSION | $jellyfinVersionToDownload IS DOWNLOADED ALREADY" $logFile
		echo "> ERROR: That version of Jellyfin is already downloaded"
		echo "> Please use 'jellyman -vs' to switch Jellyfin versions."
		return 0
	else
		return 1
	fi
}

CheckDiskFree()
{
	source $sourceFile
	if [ ! -n $defaultPath ]; then
		Log "ERROR | CHECK-DISK-FREE | NO DEFAULT MEDIA DIR FOUND!" $logFile
		echo "+-----------------------------------------------+"
		echo "|          No default directory found...        |"
		echo "|     Please enter the root directory for       |"
		echo "|              your Media Library               |"
		echo "|    DO NOT ENTER YOUR USER DIRECTORY AS IT     |"
		echo "|    WILL RESET PERMISSIONS OF THE ENTERED      |"
		echo "|       DIRECTORY TO YOUR JELLYFIN USER         |"
		echo "+-----------------------------------------------+"
		PromptUser dir "> Enter a valid directory"
		defaultPath="$promptResult"
		defaultPath=($defaultPath)
		SetVar defaultPath $defaultPath "$sourceFile" array
		df -h ${defaultPath[*]}
	else 
		df -h ${defaultPath[*]}
	fi
}

GetJellymanVersion()
{
	echo "Jellyman $jellymanVersion"
}

GetJellyfinVersion()
{
	HasSudo
	source $sourceFile
	versionFormatted=$(echo "$currentVersion" | sed -r "s|_| v|g" | sed -r "s|j|J|g")
	echo "$versionFormatted"
}

VersionDownload()
{
	HasSudo
	source $sourceFile
	versionListVar=$(curl -sL https://repo.jellyfin.org/files/server/linux/stable/)
	versionList=$(echo "$versionListVar" | grep '>v' | cut -d '>' -f 2 | cut -d '/' -f 1)
	versionListNumbered=$(echo "$versionList" | cat -n)
	maxNumber=$(echo "$versionList" | wc -l)

	echo "> **WARNING** If Jellyfin v10.9.0 or later has been installed, it is impossible to revert to older versions as they will no longer be supported by Jellyman"
	echo "> Current Jellyfin version installed"
	echo "> $currentVersion"
	echo
	echo "> Please select a stable version:"
	echo $warning
	echo "$versionListNumbered"
	echo "> Please enter the number corresponding with"
	PromptUser num "  the version you want to install" 1 $maxNumber "1-$maxNumber"
	versionToSwitchNumber=$promptResult
	newVersionNumber=$(echo "$versionList" | head -n $versionToSwitchNumber | tail -n 1 | sed -r "s|v||g")
	newVersionHyphen=$(echo "$newVersionNumber"-)
	echo "> https://repo.jellyfin.org/files/server/linux/stable/v$newVersionNumber/$architecture/jellyfin_$newVersionHyphen$architecture.tar.gz"
	jellyman -u "https://repo.jellyfin.org/files/server/linux/stable/v$newVersionNumber/$architecture/jellyfin_$newVersionHyphen$architecture.tar.gz"
	Log "VERSION-DOWNLOAD | Downloaded version from https://repo.jellyfin.org/files/server/linux/stable/v$newVersionNumber/$architecture/jellyfin_$newVersionHyphen$architecture.tar.gz" $logFile
}

VersionSwitch()
{
	HasSudo
	source $sourceFile
	versionToSwitchNumber=0
	installedVersions=$(ls /opt/jellyfin/ | grep "_")
	installedVersionsClean=$(echo "$installedVersions" | sed -r "s|j|J|g" | sed -r "s|_| v|g")
	maxNumber=$(echo "$installedVersions" | wc -l)
	warning=

	clear
	echo "> Current Jellyfin version installed"
	echo "> $currentVersion"
	echo
	echo "> Jellyfin versions already downloaded:"
	echo "$installedVersionsClean" | cat -n
	echo "> Please enter the number corresponding with"
	PromptUser num "  the version you want to install" 1 $maxNumber "1-$maxNumber"
	versionToSwitchNumber=$promptResult
	newVersion=$(echo "$installedVersions" | head -n $versionToSwitchNumber | tail -n 1)
	jellyman -S
	unlink /opt/jellyfin/jellyfin
	ln -s /opt/jellyfin/$newVersion /opt/jellyfin/jellyfin
	chown -Rf $defaultUser:$defaultUser /opt/jellyfin/jellyfin
	SetVar currentVersion $newVersion "$sourceFile"
	echo "> Jellyfin is now using v$newVersion"
	Log "VERSION-SWITCH | Jellyfin is now using v$newVersion" $logFile
	jellyman -s
}

VersionRemove()
{
	HasSudo
	source $sourceFile
	installedVersions=$(ls /opt/jellyfin/ | grep "_")
	installedVersionsClean=$(echo "$installedVersions" | sed -r "s|j|J|g" | sed -r "s|_| v|g")
	maxNumber=$(echo "$installedVersions" | wc -l)

	echo "> Current Jellyfin version installed"
	echo "> $currentVersion"
	echo
	echo "> Jellyfin versions already downloaded:"
	echo "$installedVersionsClean" | cat -n
	echo
	echo "> Please enter the number corresponding with"
	PromptUser num "  the version you want to ERASE" 1 $maxNumber "1-$maxNumber"
	versionToRemoveNumber=$promptResult
	versionToRemove=$(echo "$installedVersions" | head -n $versionToRemoveNumber | tail -n 1)

	if isInstalledVersion $versionToRemove; then
		echo "> ERROR: $versionToRemove is the currently running version. Before removing $versionToRemove" you must use jellyman -vs and choose a different version.
		exit
	fi

	echo "> Removing /opt/jellyfin/$versionToRemove"
	Countdown 5
	rm -rfv /opt/jellyfin/$versionToRemove
	Log "VERSION-REMOVE | Removed /opt/jellyfin/$versionToRemove" $logFile
}

Import()
{
	HasSudo
	source $sourceFile
	importTar=$1
	importDir=
	logFile=/tmp/jellyman.log
	
	if [[ ! -n $importTar ]]; then
		if [[ -n $backupDir ]]; then
			importDir=$backupDir	
		else
			PromptUser dir "> Please enter the directory to your jellyfin-backup.tar archives." 0 0 "/path/to/backups"
			importDir=$promptResult
		fi

		PresentList "$importDir" "> Please enter the number corresponding with the archive you wish to import." "jellyfin-backup"
		backupToImport=$presentListResult
		importTar="$importDir/$backupToImport"
	fi

	echo
	echo "+--------------------------------------------------------------------+"
	echo "|                        ******CAUTION******                         |"
	echo "|      This import procedure will erase /opt/jellyfin COMPLETELY     |"
	echo "+--------------------------------------------------------------------+"

	if PromptUser yN "> Import $importTar?"; then
		Log "IMPORT | Initiating import of $importTar" $logFile
		oldDefaultUser=$defaultUser
		echo "> IMPORTING $importTar"
		jellyman -S -d

		if [[ -d /opt/jellyfin ]]; then
			rm -rf /opt/jellyfin
			Log "IMPORT | Removed /opt/jellyfin" $logFile
		fi

		tar xf $importTar -C /
		Log "IMPORT | $importTar restored at /opt/jellyfin" $logFile
		cat "$logFile" >> /opt/jellyfin/log/jellyman.log
		logFile=/opt/jellyfin/log/jellyman.log
		source $sourceFile
		mv -f /opt/jellyfin/backup/jellyfin.conf /etc/
		mv -f /opt/jellyfin/backup/*.service $jellyfinServiceLocation/
		mv -f /opt/jellyfin/backup/jellyfin-backup.timer $jellyfinServiceLocation/
		systemctl daemon-reload
		if [[ -n $autoBackups ]] && $autoBackups; then
			systemctl enable --now jellyfin-backup.timer
			Log "IMPORT | autoBackups=true, enabled jellyfin-backup.timer" $logFile
		else
			if PromptUser Yn "Enable automatic backups?" 0 0 "Y/n"; then
				systemctl enable --now jellyfin-backup.timer
				SetVar autoBackups true "$sourceFile" str
				SetVar "backupFrequency" "weekly" "$sourceFile"
				Log "IMPORT | User enabled automatic backups" $logFile
			else
				systemctl enable --now jellyfin-backup.timer
				SetVar autoBackups false "$sourceFile" str
				SetVar "backupFrequency" "weekly" "$sourceFile"
				Log "IMPORT | User disabled automatic backups" $logFile
			fi
		fi
		
		if [[ "$oldDefaultUser" == "$defaultUser" ]]; then
			chown -Rf $defaultUser:$defaultUser /opt/jellyfin
			chmod -Rf 770 /opt/jellyfin
			jellyman -e -s
			echo "> IMPORT COMPLETE!"
			Log "IMPORT | Imported LINUX user is the same as current LINUX user" $logFile
			Log "IMPORT | Import completed" $logFile
		else
			groupdel $oldDefaultUser
			userdel $oldDefaultUser
			echo
			echo "> The previous LINUX user $oldDefaultUser does not match the imported user $defaultUser"
			if PromptUser yN "> Would you like to create the imported LINUX user $defaultUser?"; then
				Log "IMPORT | Creating LINUX user $defaultUser" $logFile
				echo "> Creating LINUX user $defaultUser"
				useradd -rd /opt/jellyfin $defaultUser
				chown -Rf $defaultUser:$defaultUser /opt/jellyfin
				chmod -Rf 770 /opt/jellyfin
				SetVar User "$defaultUser" "$jellyfinServiceLocation/jellyfin.service" str
				Log "IMPORT | User $defaultUser $jellyfinServiceLocation/jellyfin.service" $logFile
				jellyman -e -s -t
			else
				PromptUser usr "> Please enter a new LINUX user." 0 0 "jellyfin"
				defaultUser=$promptResult
				while id "$defaultUser" &>/dev/null; do
					Log "IMPORT | Attempted to create $default user, but that user already exists" $logFile
					echo "> Cannot create $defaultUser as $defaultUser already exists..."
					PromptUser usr "> Please re-enter a new default Linux user for Jellyfin"
					defaultUser=$promptResult
				done
		 
				defaultUser=${defaultUser,,}
				echo "> Linux user = $defaultUser"
				useradd -rd /opt/jellyfin $defaultUser
				Log "IMPORT | Created LINUX user $defaultUser" $logFile
				
				chown -Rf $defaultUser:$defaultUser /opt/jellyfin
				chmod -Rf 770 /opt/jellyfin
				SetVar User "$defaultUser" "$jellyfinServiceLocation/jellyfin.service" str
				Log "IMPORT | User $defaultUser $jellyfinServiceLocation/jellyfin.service" $logFile
				jellyman -e -s -t
			fi
		fi
	else
		echo "> Returning..."
		return 0
		exit
	fi
}

LibraryScan()
{
	HasSudo
	source $sourceFile
	CheckApiKey
	curl -d POST http://localhost:$httpPort/Library/Refresh?api_key=$apiKey
	Log "LIBRARY-SCAN | Initiated library scan" $logFile
}

ImportApiKey()
{
	HasSudo
	echo "> Create a API key by signing into Jellyfin, going to Dashboard, then"
	echo "> clicking on API Keys under the Advanced section on the left."
	echo
	PromptUser str "> Please paste your API Key" 0 0 "API key"
	newAPIKey=$promptResult
	echo "> Logging new api key."
	SetVar apiKey $newAPIKey "$sourceFile"
	Log "IMPORT-API-KEY | Imported new API key" $logFile
}

CheckApiKey()
{
	HasSudo
	source $sourceFile
	if [[ ! -n $apiKey ]]; then
		Log "ERROR | CHECK-API-KEY | NO API KEY FOUND" $logFile
		echo "> ERROR: NO API KEY FOUND, RUN 'sudo jellyman -ik' TO IMPORT A NEW KEY!"
		return 1
		exit
	else
		return 0
	fi
}

HttpPortChange()
{
	HasSudo
	source $sourceFile
	echo
	echo "> Default http port is 8096"
	if IsJellyfinSetup; then
		PromptUser num "> Please enter the new http network port for Jellyfin" 1000 100000 "http port"
		port=$promptResult
		oldPort=$httpPort
		SetVar httpPort $port "$sourceFile"
		jellyman -S
		SetXmlVar InternalHttpPort "$port" "/opt/jellyfin/config/network.xml"
		SetXmlVar PublicHttpPort "$port" "/opt/jellyfin/config/network.xml"
		jellyman -s
		echo "> Unblocking port $port"
		echo "> Blocking previous port $oldPort"
		if [ -x "$(command -v ufw)" ]; then
			ufw allow $port
			ufw deny $oldPort
			ufw reload
			Log "HTTP-PORT-CHANGE | Used ufw to change port from $oldPort to $port" $logFile
		elif [ -x "$(command -v firewall-cmd)" ]; then 
			firewall-cmd --permanent --add-port=$port/tcp
			firewall-cmd --permanent --remove-port=$oldPort/tcp
			firewall-cmd --reload
			Log "HTTP-PORT-CHANGE | Used firewallD to change port from $oldPort to $port" $logFile
		else
			Log "ERROR | HTTP-PORT-CHANGE | FAILED TO OPEN PORT $port! NO 'ufw' OR 'firewall-cmd' COMMAND FOUND!" $logFile
			echo "> ERROR: FAILED TO OPEN PORT $port!"
			echo "> REASON: NO 'ufw' OR 'firewall-cmd' COMMAND FOUND!"
		fi
	else
		exit
	fi
}

HttpsPortChange()
{
	HasSudo
	source $sourceFile
	if IsJellyfinSetup; then
		echo "> Default https port is 8920"
		PromptUser num "> Please enter the new https network port for Jellyfin" 1000 100000 "https port"
		port=$promptResult
		oldPort=$httpsPort
		SetVar httpsPort $port "$sourceFile"
		jellyman -S
		SetXmlVar InternalHttpsPort "$port" "/opt/jellyfin/config/network.xml"
		SetXmlVar PublicHttpsPort "$port" "/opt/jellyfin/config/network.xml"
		jellyman -s
		echo "> Unblocking port $port"
		echo "> Blocking previous port $oldPort"
		if [ -x "$(command -v ufw)" ]; then
			ufw allow $port
			ufw deny $oldPort
			ufw reload
			Log "HTTPS-PORT-CHANGE | Used ufw to change port from $oldPort to $port" $logFile
		elif [ -x "$(command -v firewall-cmd)" ]; then 
			firewall-cmd --permanent --add-port=$port/tcp
			firewall-cmd --permanent --remove-port=$oldPort/tcp
			firewall-cmd --reload
			Log "HTTPS-PORT-CHANGE | Used firewallD to change port from $oldPort to $port" $logFile
		else
			Log "ERROR | HTTPS-PORT-CHANGE | FAILED TO OPEN PORT $port! NO 'ufw' OR 'firewall-cmd' COMMAND FOUND!" $logFile
			echo "> ERROR: FAILED TO OPEN PORT $port!"
			echo "> REASON: NO 'ufw' OR 'firewall-cmd' COMMAND FOUND!";
		fi
	else
		exit
	fi
}


Permissions()
{
	HasSudo
	source $sourceFile
	checkForDefaultPath="yes"
	directoryToFix=

	if [[ -d "$1" ]]; then
		directoryToFix=$1
		echo "> Setting permissions for "$directoryToFix""
		time $(
			chown -Rf $defaultUser:$defaultUser "$directoryToFix"
			chmod -Rf 770 "$directoryToFix"
			chmod -Rf ug+X "$directoryToFix"
			Log "PERMISSIONS | Set permissions with chown $defaultUser:$defaultUser $directoryToFix" $logFile
		)
		echo "> ...DONE"
	elif [[ ! -d "$1" ]] && [[ -n "$1" ]]; then
		Log "ERROR | PERMISSIONS | User tried to set permissions, but supplied an invalid directory" $logFile
		echo "> $1 is not a directory. Please enter a absolute path to your media"
		echo "> EXITING..."
		exit
	else
		#Check if there is a recorded media library path for chown and chmod:
		if AreDirectories "${defaultPath[*]}" || [[ -d $defaultPath ]] || [[ -n $defaultPath ]]; then
			echo "> Setting permissions for ${defaultPath[*]}"
			time $(
				chown -Rf $defaultUser:$defaultUser ${defaultPath[*]}
				chmod -Rf 770 ${defaultPath[*]}
				chmod -Rf ug+X ${defaultPath[*]}
				Log "PERMISSIONS | Set permissions with chown $defaultUser:$defaultUser ${defaultPath[*]}" $logFile
			)
		else
			Log "ERROR | PERMISSIONS | User tried to set permissions, but function could not find the defaultDir" $logFile
			echo "> No default media directory found..."
			echo "> Running sudo jellyman -md to change media directory in:"
			Countdown 5
			jellyman -md
		fi

		echo "> ...DONE"
	fi
}

Status()
{
	systemctl status jellyfin.service
	echo
	echo
	CheckDiskFree
}

Update()
{
	HasSudo
	source $sourceFile
	customVersionLink=
	customVersion=""
	fileType=""
	jellyfin_archive=""
	jellyfin=""
	new_jellyfin_version=""
	newJellyfinArchive=""

	if [[ ! -d /opt/jellyfin/update ]]; then
		mkdir /opt/jellyfin/update
	fi
	
	if [[ $1 == *"://"* ]] ; then 
		customVersionLink=$1
		customVersion=$(echo $customVersionLink | rev | cut -d/ -f1 | rev)
		jellyfin_archive=$customVersion
		newJellyfinArchive=$jellyfin_archive
		jellyfin=$(echo $jellyfin_archive | sed -r "s|-$architecture.tar.gz||g")
		fileType=$(echo $customVersion | cut -d '-' -f2)
		
		if isDownloadedVersion $jellyfin; then
			Log "ERROR | UPDATE | Tried to update with a custom URL, but the URL points to an already downloaded version" $logFile
			return 1
		elif [[ $fileType != "$architecture.tar.gz" ]]; then
			Log "ERROR | UPDATE | Tried to update with a custom URL, but the URL doesn't point to a .tar.gz" $logFile
			echo "> Supplied URL does not point to a $architecture.tar.gz.. EXITING..."
			return 1
		fi
		
		echo "> Fetching custom Jellyfin version..."
		wget -P /opt/jellyfin/update/ $customVersionLink
		Log "UPDATE | Updated Jellyfin with $customVersionLink" $logFile
	else
		stableReleases=$(curl -sL https://repo.jellyfin.org/?path=/server/linux/latest-stable/$architecture/)
		jellyfin_archive=$(echo "$stableReleases" | grep -Po jellyfin_[^_]+-$architecture.tar.gz | head -1)
		jellyfin=$(echo "$jellyfin_archive" | sed -r "s|-$architecture.tar.gz||g")
		newJellyfinArchive=$(echo "$jellyfin"-$architecture.tar.gz)
		
		# echo "jellyfin_archive = $jellyfin_archive"
		# echo "jellyfin = $jellyfin"
		# echo "currentVersion = $currentVersion"
		if ! isInstalledVersion $jellyfin && ! isDownloadedVersion $jellyfin; then
			echo "> Getting current version from repository..."
			wget -O /opt/jellyfin/update/$newJellyfinArchive https://repo.jellyfin.org/files/server/linux/latest-stable/$architecture/$jellyfin_archive
			Log "UPDATE | Downloaded newest Jellyfin release found at https://repo.jellyfin.org/files/server/linux/latest-stable/$architecture/$jellyfin_archive" $logFile
		else
			exit
		fi
	fi
	
	new_jellyfin_version=$(echo $jellyfin | sed -r 's/jellyfin_//g')
	echo "> Unpacking $jellyfin_archive to /opt/jellyfin/$jellyfin"
	jellyman -S
	unlink /opt/jellyfin/jellyfin
	tar xvzf /opt/jellyfin/update/$newJellyfinArchive -C /opt/jellyfin/
	
	if [ -n "$(ls -A /opt/jellyfin/jellyfin/ 2>/dev/null)" ]; then
		mv -f /opt/jellyfin/jellyfin /opt/jellyfin/$jellyfin
		Log "UPDATE | Successfully unpacked $newJellyfinArchive to /opt/jellyfin/$jellyfin" $logFile
	else
		Log "ERROR | UPDATE | Attempted to unpack /opt/jellyfin/update/$newJellyfinArchive, but the archive is empty!" $logFile
		echo "> ERROR Attempted to unpack /opt/jellyfin/update/$newJellyfinArchive, but the archive is empty!"
	fi

	ln -s /opt/jellyfin/$jellyfin /opt/jellyfin/jellyfin
	echo "> Removing $jellyfin_archive"
	Log "UPDATE | Removed $jellyfin_archive" $logFile
	rm -rfv /opt/jellyfin/update

	chown -R $defaultUser:$defaultUser /opt/jellyfin
	echo "> Jellyfin updated to version $new_jellyfin_version"
	SetVar currentVersion $jellyfin "$sourceFile"
	Log "UPDATE | SetVar currentVersion=$jellyfin" $logFile
	jellyman -s -t
}


# needs testing when new beta is available
UpdateBeta()
{
	HasSudo
	source $sourceFile
	betasAvailable=$(curl -sL https://repo.jellyfin.org/?path=/server/linux/latest-unstable/$architecture/)
	jellyfinArchives=$(echo "$betasAvailable" | grep -o ">jellyfin_.*-$architecture.tar.gz<" | cut -d "'" -f 1 | sed -r "s|<||g" | sed -r "s|>||g" | head -1)
	jellyfinNumbered=$(echo "$jellyfinArchives" | sed -r "s|-$architecture.tar.gz||g" | cat -n)
	versionSelected=0
	maxNumber=$(echo "$jellyfinNumbered" | wc -l)
	newVersionName=
	newVersionNumber=
	newVersionArchive=
	warning=""
	
	if [[ ! $betasAvailable == .*"tar.gz".* ]]; then
		Log "UPDATE-BETA | Tried to update to newest beta, but there are no betas available." $logFile
		echo "> Sorry, no betas are available right now..."
		exit
	fi

	clear
	echo "> Available betas:"
	echo $warning
	echo "$jellyfinNumbered"
	echo

	PromptUser num "> Select which version to install" 1 $maxNumber "1-$maxNumber"
	versionSelected=$promptResult
	newVersionName=$(echo "$jellyfinArchives" | head -n $versionSelected | tail -n 1 | sed -r "s|-$architecture.tar.gz||g")
	newVersionNumber=$(echo $newVersionName | sed -r 's/jellyfin_//g')
	if isInstalledVersion $newVersionName || isDownloadedVersion $newVersionName; then
		Log "ERROR | UPDATE-BETA | Tried to update to a selected beta, but the beta is already installed" $logFile
		warning="> ERROR: That Jellyfin version is already installed!"
		echo "> Press CTRL+C to exit..."
	else
		newVersionArchive=$(echo "$jellyfinArchives" | head -n $versionSelected | tail -n 1)
		echo "> Getting $newVersionArchive..."
		wget -O /opt/jellyfin/update/$newVersionName https://repo.jellyfin.org/files/server/linux/latest-unstable/$architecture/$newVersionArchive
		echo "> Unpacking $newVersionArchive to /opt/jellyfin/..."
		tar xvzf /opt/jellyfin/update/$newVersionArchive -C /opt/jellyfin/
		Log "UPDATE-BETA | Unpacked $newVersionArchive to /opt/jellyfin/" $logFile
		jellyman -S
		unlink /opt/jellyfin/jellyfin
		ln -s /opt/jellyfin/$newVersionName /opt/jellyfin/jellyfin
		echo "> Removing $newVersionArchive"
		rm -rfv /opt/jellyfin/update
		Log "UPDATE-BETA | Removed /$newVersionArchive" $logFile

		chown -R $defaultUser:$defaultUser /opt/jellyfin
		echo "> Jellyfin updated to version $newVersionNumber"
		SetVar currentVersion $newVersionName "$sourceFile"
		Log "UPDATE-BETA | SetVar currentVersion=$newVersionName" $logFile
		jellyman -s -t
	fi
}

RecertifyHttps()
{
	HasSudo
	source $sourceFile
	echo "+------------------------------------------------------+"
	echo "|  Creating OpenSSL self signed certificate for https. |"
	echo "|             Valid for the next 365 days.             |"
	echo "|       This only works if you have completed          |" 
	echo "|           first time setup in Jellyfin               |"
	echo "+------------------------------------------------------+"
	source $sourceFile
	if IsJellyfinSetup; then
		rm -fv /opt/jellyfin/cert/*
		openssl req -x509 -newkey rsa:4096 -keyout /opt/jellyfin/cert/privkey.pem -out /opt/jellyfin/cert/cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'
		openssl pkcs12 -export -out /opt/jellyfin/cert/jellyfin.pfx -inkey /opt/jellyfin/cert/privkey.pem -in /opt/jellyfin/cert/cert.pem -passout pass:
		echo "> Enabling https..."
		jellyman -S
		SetXmlVar EnableHttps "true" "/opt/jellyfin/config/network.xml"
		SetXmlVar CertificatePath "/opt/jellyfin/cert/jellyfin.pfx" "/opt/jellyfin/config/network.xml"
		chown -Rf $defaultUser:$defaultUser /opt/jellyfin/cert
		chmod -Rf 770 /opt/jellyfin/cert
		jellyman -s
		Log "RECERTIFY-HTTPS | Finished recertify process" $logFile
	else
		exit
	fi
}

RenameTv()
{
	HasSudo
	source $sourceFile
	nameOfTestFile=
	loop=true
	while $loop; do
		clear
		echo "|--------------------------------------------------------------|"
		echo "|                        ***WARNING***                         |"
		echo "|       TV SHOW FILE NAMES MUST CONTAIN 'SXXEXX' X=number      |"
		echo "|                                                              |"
		echo "|            Please enter the directory to correct             |"
		echo "|                        For example:                          |"
		echo "|  /jfin/TV/*/*/* <- For every Episode(May Crash Be Careful!)  |"
		echo "|                            OR:                               |"
		echo "|  /jfin/TV/Breaking*Bad/*/* <- For Every Episode in a show    |"
		echo "|                            OR:                               |"
		echo "|  /jfin/TV/Breaking*Bad/Season*2/* <- For Every Episode in    |"
		echo "|                    a season of a show                        |"
		echo "|                                                              |"
		echo "|      BE ADVISED, IF YOU'RE RE-NAMING MULTIPLE SHOWS,         |"
		echo "|             MAKE SURE ALL THE SHOW DIRECTORY                 |"
		echo "|      NAMES ARE IN THE SAME LOCATION IN THE DIRECTORY         |"
		echo "|--------------------------------------------------------------|"
		echo
		PromptUser str "> Please enter a directory" 0 0 "directory"
		directoryToCorrect=$promptResult
		clear
		nameOfTestFile=$(ls -1 $directoryToCorrect | head -1)
		if [ -f "$nameOfTestFile" ]; then
			loop=false
		else
			echo "> Path does not exist, please try again."
		fi
	done
	
	testDirCount=$(echo $nameOfTestFile | grep -o "/" | wc -w)

	if [[ $directoryToCorrect != *"/" ]]; then
		testDirCount=$(($testDirCount + 1))
	fi

	iteration=2
	number=1

	while [ $number -lt $testDirCount ]; do
		testName=$(echo $nameOfTestFile | cut -d "/" -f $iteration)
		echo "> $number : $testName"
		iteration=$(($iteration + 1))
		
		number=$(($number + 1))	
	done
	
	echo "> Please enter the number that corresponds with the show's name above"
	read directoryNumber
	directoryNumber=$(($directoryNumber + 1))
	nameOfShow=$(dirname "$directoryToCorrect" | cut -d "/" -f $directoryNumber)
	echo "> You chose $nameOfShow"

	for item in $directoryToCorrect
	do
		echo $item
			if [[ "$item" == *[sS][0-9][0-9][eE][0-9][0-9]* ]]; then
				extensionOfFile="${item##*.}"
				nameOfDirectory=$(dirname "$item")
				nameOfShow=$(dirname "$item" | cut -d "/" -f $directoryNumber)
				episodeNumber=$(echo "$item" | grep -oE '[sS][0-9][0-9][eE][0-9][0-9]')
				mv "$item" "$nameOfDirectory/$nameOfShow $episodeNumber.$extensionOfFile"
				newItemName="$nameOfDirectory/$nameOfShow $episodeNumber.$extensionOfFile"
				echo "> item:"
				echo "> $item"
				#echo "Directory:"
				#echo "$nameOfDirectory"
				#echo "Name Of Show:"
				#echo $nameOfShow
				#echo "Episode:"
				#echo "$episodeNumber"
				#echo "extension of file:"
				#echo "$extensionOfFile"
				echo "> New Name:"
				echo "> $newItemName"
				chown -f $defaultUser:$defaultUser "$newItemName"
				chmod -f 770 "$newItemName"
				echo
				Log "RENAME-TV | $item -> $newItemName" $logFile
			fi
	done
}

Uninstall()
{
	HasSudo
	source $sourceFile
	echo "|-------------------------------------------------------------------|"
	echo "|                        ******WARNING******                        |"
	echo "|                        ******CAUTION******                        |"
	echo "|                     Are you completely sure?                      |"
	echo "|          This will delete all files relating to Jellyfin          |"
	echo "|   and Jellyman, except the Media Library and jellyfin-backup.tar  |"
	echo "|-------------------------------------------------------------------|"
	echo
	if PromptUser yN "> CONTINUE?"; then
		echo "> Goodbye..."
		echo "> Removing Jellyfin and Jellyman in:"
		Countdown 5
		echo "> Blocking ports 8096 and 8920..."
		if [ -x "$(command -v ufw)" ]; then
			ufw deny $httpPort/tcp
			ufw deny $httpsPort/tcp
			ufw reload
		elif [ -x "$(command -v firewall-cmd)" ]; then
			firewall-cmd --permanent --remove-port=$httpPort/tcp
			firewall-cmd --permanent --remove-port=$httpsPort/tcp
			firewall-cmd --reload
		else
			echo "|-------------------------------------------------------------------|"
			echo "|                        ******WARNING******                        |"
			echo "|                        ******CAUTION******                        |"
			echo "|                  FAILED TO CLOSE PORT 8096/8920!                  |"
			echo "|          ERROR NO 'ufw' OR 'firewall-cmd' COMMAND FOUND!          |"
			echo "|-------------------------------------------------------------------|"
		fi
		
		echo "> Disabling and stopping Jellyfin..."
		jellyman -d -S
		systemctl disable --now jellyfin-backup.timer
		echo "> Deleting /etc/jellyfin.conf and $jellyfinServiceLocation/jellyfin.service..."
		rm -f /etc/jellyfin.conf $jellyfinServiceLocation/jellyfin*
		echo "> Deleting LINUX user $defaultUser"
		userdel -f $defaultUser
		echo "> Deleting the /opt/jellyfin directory..."
		rm -rf /opt/jellyfin
		echo "> Deleting Jellyman..."
		rm -f /usr/bin/jellyman-functions /usr/bin/jellyman
	else
		echo "> Phew! That was a close one!"
	fi
}

KillJob()
{
	# Run a job '_ID="jellyman-tc && COMMAND &'
	# To kill a job `KillJob "jellyman-tc"
	_jobName=$1
	_jobID=$(jobs | grep "$_jobName" | cut -d "[" -f 2 | cut -d "]" -f 1)
	kill %$_jobID
	Log "KILL-JOB | Killed job $_jobID" $logFile
}

CallFunc()
{
	HasSudo
	source $sourceFile
	$1
}

ProgressBar()
{
	progressBarConf="/tmp/jellyman_transcode.conf"
	if [ -f $progressBarConf ]; then
		source $progressBarConf
		currentState=$startState
		totalState=$maxState
		currentVideoSizeMB=$(du -m "$currentVideo" | cut -d "	" -f 1)
		previousVideoSizeMB=$(du -m "$previousVideo" | cut -d "	" -f 1)
		sizeSavingsPercent=$(bc -l <<< "$currentVideoSizeMB/$previousVideoSizeMB*100")
		sizeSavingsPercent=$(bc -l <<< "100-$sizeSavingsPercent" | cut -c 1-4)'%'
		let _progress=(${currentState}*100/${totalState}*100)/100
		let _done=(${_progress}*4)/10
		let _left=40-$_done
		_fill=$(printf "%${_done}s")
		_empty=$(printf "%${_left}s")

		printf "\rTranscoded : [$currentState/$totalState] [${_fill// /#}${_empty// /-}] ${_progress}%%"
		printf "\nTranscoding File : $previousVideo \n"
		echo "> Original Size    : $previousVideoSizeMB MB"
		echo "> New Size         : $currentVideoSizeMB MB"
		echo "> Percentave Saved : $sizeSavingsPercent"

		if [ $currentState -eq $totalState ]; then
			printf '\nFinished!\n'
		fi
	else
		echo "> loading..."
	fi
}

ViewTranscodeProgress()
{
	while true; do
		clear
		ProgressBar
		echo
		echo "> CTRL+C to exit progress bar"
		echo "> 'jellyman -tcp' to bring back Transcode Progress"
		sleep 3
	done
}

QualifyTranscode()
{
	videoToEdit="$1"
	desiredGBperHour=$2
	qualifiedVideos="/tmp/jellyman_qualified_videos.txt"

	videoSize=$(du -h "$videoToEdit" | cut -d "/" -f 1)
	videoInformation=$(ffprobe -v quiet -show_streams "$videoToEdit")
	videoWidth=$(ffprobe -v quiet -show_streams -select_streams v:0 $currentVideo | grep ^width= | cut -d "=" -f 2)
	videoDuration=$(echo "$videoInformation" | grep "duration=" | cut -d "=" -f 2 | cut -d "." -f 1 | head -n 1)

	if [[ $videoWidth -gt 1920 ]]; then
		desiredGBperHour=$(echo "$desiredGBperHour*2.5" | bc)
	fi

	if IsVideo "$videoToEdit"; then
		_videoSizeGB=null
		_videoTimeHours=$(bc -l <<< "$videoDuration/3600")
		if [[ $videoSize == *"M"* ]]; then
			_videoSizeMB=$(echo $videoSize | sed -r "s|M||g" | cut -d "	" -f 1)
			_videoSizeGB=$(bc -l <<< "$_videoSizeMB/1024")
		else
			_videoSizeGB=$(echo $videoSize | sed -r "s|G||g")
		fi
		_videoRatio=$(bc -l <<< "$_videoSizeGB/$_videoTimeHours")
		if [ 1 -eq "$(echo "$_videoRatio > $desiredGBperHour" | bc)" ]; then
			echo "> Transcoding $videoToEdit ..."
			_newName=$(echo $videoToEdit | rev | cut -d "." -f 2 | rev)
			echo "> Video time in Hours: $_videoTimeHours"
			echo "> Video size GB: $_videoSizeGB"
			echo "> Current GB/Hour: $_videoRatio"
			echo "$videoToEdit" >> $qualifiedVideos
			Log "QUALIFY-TRANSCODE | Added file $videoToEdit to transcode list, Duration:$_videoTimeHours Hrs Size:$_videoSizeGB GiB GiB/Hr:$_videoRatio" $logFile
		else
			echo "> $videoToEdit is less than $desiredGBperHour GB/Hour, skipping..."
		fi
	else
		_file=$(echo $videoToEdit | rev | cut -d "/" -f 1 | rev)
		echo "> $_file is not a video, skipping..."
	fi
}

TranscodeStop()
{
	qualifiedVideos="/tmp/jellyman_qualified_videos.txt"
	progressBarConf="/tmp/jellyman_transcode.conf"
	screen -XS jellyman_transcode quit
	Log "TRANSCODE-STOP | Stopped transcodes" $logFile
	rm $qualifiedVideos
	rm $progressBarConf
}

TranscodeFile()
{
	deleteOrNot=$1
	preset=$2
	crf=$3
	qualifiedVideos="/tmp/jellyman_qualified_videos.txt"
	progressBarConf="/tmp/jellyman_transcode.conf"
	totalVideos=$(cat "$qualifiedVideos" | wc -l)
	iteration=0
	currentVideo=

	while [ ! $iteration -eq $totalVideos ]; do
		iteration=$(($iteration + 1))
		currentVideo=$(cat "$qualifiedVideos" | head -n $iteration | tail -n 1)
		_newName=$(echo $currentVideo | rev | cut -d "." -f 2 | rev)
		_progressIteration=$(($iteration - 1))
#		_progress=$(ProgressBar $_progressIteration $totalVideos)
#		echo "$_progress" > $progressBarFile

		echo '#!/bin/bash' > "$progressBarConf"
		SetVar startState "$_progressIteration" "$progressBarConf" str
		SetVar maxState "$totalVideos" "$progressBarConf" str
		SetVar currentVideo "$_newName.downsampled.mp4" "$progressBarConf" str
		SetVar previousVideo "$currentVideo" "$progressBarConf" str

		echo "> Transcoding $currentVideo"

		_videoTransfer=$(ffprobe -v quiet -show_streams -select_streams v:0 $currentVideo | grep ^color_transfer= | cut -d "=" -f 2)
		if [[ $_videoTransfer == "arib-std-b67" ]] || [[ $_videoTransfer == "smpte2084" ]]; then
			Log "TRANSCODE-FILE | File $currentVideo is HDR" $logFile
			nice ffmpeg -y -i "$currentVideo" -c:v libsvtav1 -c:a copy -movflags +faststart -pix_fmt yuv420p10le -colorspace bt2020nc -color_trc smpte2084 -color_primaries bt2020 -crf $crf "$_newName.downsampled.mp4"
		else
			Log "TRANSCODE-FILE | File $currentVideo is not HDR" $logFile
			nice ffmpeg -y -i "$currentVideo" -c:v libsvtav1 -c:a copy -movflags +faststart -preset $preset -crf $crf "$_newName.downsampled.mp4"
		fi
		_newVideoSize=$(du -h "$_newName.downsampled.mp4" | cut -d "/" -f 1)
		echo "> Downsampled size: $_newVideoSize"
		if $deleteOrNot; then
			echo "> DELETING $currentVideo IN:"
			Countdown 10
			rm -v "$currentVideo"
			mv -v "$_newName.downsampled.mp4" "$_newName.mp4"
			Log "TRANSCODE-FILE | Replaced $currentVideo with $_newName.downsampled.mp4" $logFile
		fi
	done

	sed -i "s|startState=.*|startState=$totalVideos|g" "$progressBarConf"
	sleep 10
	rm $qualifiedVideos
	exit
}

Transcode()
{
	echo "+--------------------------------------------------------------+"
	echo "|                        ***WARNING***                         |"
	echo "|          Please enter the directory to transcode             |"
	echo "|                        For example:                          |"
	echo "|  /jfin/TV/*/*/* <- For every Episode(May Crash Be Careful!)  |"
	echo "|                            OR:                               |"
	echo "|  /jfin/TV/Breaking*Bad/*/* <- For Every Episode in a show    |"
	echo "|                            OR:                               |"
	echo "|  /jfin/TV/Breaking*Bad/Season*2/* <- For Every Episode in    |"
	echo "|                    a season of a show                        |"
	echo "|                                                              |"
	echo "|       BE ADVISED, IF YOU'RE TRANSCODING MULTIPLE FILES,      |"
	echo "|               THIS IS GOING TO TAKE A WHILE!                 |"
	echo "+--------------------------------------------------------------+"
	PromptUser str "> Please enter the directory to the files to transcode" 0 0 "directory"
	_directoryToCorrect=$promptResult
	echo
	echo "> Please enter the desired GB per hour of video (For 1080p)"
	echo "> 4K video GB/hour is 1080p GB/hour multiplied by 2.5."
	PromptUser str "> EXAMPLE: 2 OR 2.5" 0 0 "Recommended:2-4"
	desiredGBperHour=$promptResult
	
	preset=0
	echo
	echo "---------------------------------------------------"
	echo
	echo "> Please choose a transcode preset"
	echo "> 5-8 is recommended"
	PromptUser num "> Lower values are slower but have better compression." 1 12 "1-12"
	preset=$promptResult
	
	crf=0
	echo
	echo "---------------------------------------------------"
	echo
	echo '> Please enter a Constant Rate Factor (CRF) [1-63]'
	echo "> 25-35 is recommended"
	echo
	PromptUser num "> Lower values correspond to higher quality but greater file size" 1 63 "1-63"
	crf=$promptResult
	echo
	if PromptUser yN "> Would you like to delete the original file after transcode?"; then
		deleteOrNot=true
	else
		deleteOrNot=false
	fi
	
	for item in $_directoryToCorrect
	do
		QualifyTranscode "$item" $desiredGBperHour
	done

	screen -dmS jellyman_transcode jellyman --CallFunc "TranscodeFile $deleteOrNot $preset $crf"
	Log "TRANSCODE | directoryToCorrect=$_directoryToCorrect, preset=$preset, crf=$crf, deleteOrNot=$deleteOrNot" $logFile
	sleep 1
	ViewTranscodeProgress
}

UpdateJellyman()
{
	HasSudo
	jellymanManFile=$(curl -sL https://raw.githubusercontent.com/Smiley-McSmiles/jellyman/main/jellyman.1)
	currentJellymanVersion=$(echo $jellymanManFile | grep " - v" | cut -d "v" -f2 | cut -d " " -f1)
	if [[ "v$currentJellymanVersion" == $jellymanVersion ]]; then
		echo "> Jellyman v$jellymanVersion is up to date. No new versions available."
		Log "ERROR | UPDATE-JELLYMAN | Tried to update Jellyman, but Jellyman is already at the current version" $logFile
		exit
	else
		echo "> Updating Jellyman - The Jellyfin Manager from $jellymanVersion to v$currentJellymanVersion"
		git clone https://github.com/Smiley-McSmiles/jellyman
		cd jellyman
		chmod ug+x setup.sh
		sudo ./setup.sh -U
		Log "UPDATE-JELLYMAN | Updated Jellyman from $jellymanVersion to v$currentJellymanVersion" $logFile
	fi
}

ChangeMediaDirectory()
{
	HasSudo
	mediaPath=""
	warning=""
	continue=true

	while $continue; do
		clear
		echo "|---------------------------------------------------------|"
		echo "| Please enter all media directories separated by a space |"
		echo "|                       example:                          |"
		echo "|          /media/hdd1/Movies /media/hdd2/TV              |"
		echo "|---------------------------------------------------------|"
		echo
		echo $warning
		PromptUser str " " 0 0 "/dir1 /dir2"
		mediaPath="$promptResult"
		if [[ ! -d "$mediaPath" ]]; then
			if AreDirectories "$mediaPath"; then
				continue=false
				SetVar defaultPath "$mediaPath" "$sourceFile" array
				Log "CHANGE-MEDIA-DIRECTORY | SetVar defaultPath $mediaPath $sourceFile" $logFile
				exit
			else
				warning="> ERROR: Make sure each input is a directory!"
				exit
			fi
		else
			SetVar defaultPath "$mediaPath" "$sourceFile" dir
			Log "CHANGE-MEDIA-DIRECTORY | SetVar defaultPath $mediaPath $sourceFile" $logFile
			exit
		fi
	done
}

Control(){
	HasSudo
	source $sourceFile

	case "$1" in
		start) systemctl start jellyfin
         	Log "JELLYMAN | Started Jellyfin" $logFile ;;
		stop) systemctl stop jellyfin
         	Log "JELLYMAN | Stopped Jellyfin" $logFile ;;
		enable) systemctl enable jellyfin
         	Log "JELLYMAN | Enabled Jellyfin" $logFile ;;
		disable) systemctl disable jellyfin
         	Log "JELLYMAN | Disabled Jellyfin" $logFile ;;
		restart) systemctl restart jellyfin
         	Log "JELLYMAN | Restarted Jellyfin" $logFile ;;
	esac
}

Help()
{
	# Display Help
	echo "$helpList"
}

###############################################################################
# FUNCTIONS END                                                               #
###############################################################################


###############################################################################
# MAIN                                                                        #
###############################################################################
if [ -n "$1" ]; then
	total=1
	while [ -n "$1" ]; do
		case "$1" in
			-b | --backup) Backup "$2"
				 shift ;;
			-ba | --backup-auto) BackupAuto ;;
			-bu | --backup-utility) BackupUtility ;;
			-d | --disable) Control "disable" ;;
			-e | --enable) Control "enable" ;;
			-h | --help) Help ;;
			-i | --import) Import "$2"
				 shift ;;
			-p | --permissions) if [[ "$2" == "-"* ]]; then
					 Permissions 
				 else
					 Permissions $2
					 shift 
				 fi ;;
			-r | --restart) Control "restart" ;;
			-s | --start) Control "start" ;;
			-S | --stop) Control "stop" ;;
			-t | --status) Status ;;
			-u | --update-jellyfin) if [[ "$2" == "-"* ]]; then
					 Update
				 else
					 Update $2
					 shift
				 fi ;;
			-U | --update-jellyman) UpdateJellyman
				 exit ;;
			-ub | --update-beta) UpdateBeta ;;
			-v | --version) GetJellyfinVersion
					GetJellymanVersion ;;
			-vd | --version-download) VersionDownload ;;
			-vs | --version-switch) VersionSwitch ;;
			-vr | --version-remove) VersionRemove ;;
			-vl | --view-log) HasSudo
				 ViewLog "$logDir" ;;
			-rc | --recertify) RecertifyHttps ;;
			-rn | --rename) RenameTv ;;
			-ls | --library-scan) LibraryScan ;;
			-cp | --change-http) HttpPortChange ;;
			-cps | --change-https) HttpsPortChange ;;
			-ik | --import-key) ImportApiKey ;;
			-md | --media-directory) ChangeMediaDirectory ;;
			-tc | --transcode) Transcode ;;
			-tcp | --transcode-progress) ViewTranscodeProgress ;;
#			-tcf) TranscodeFile $2 $3 $4
#						shift
#						shift
#						shift ;;
			-tcs | --transcode-stop) TranscodeStop ;;
			-X | --uninstall) Uninstall ;;
			--CallFunc) CallFunc "$2"
									shift ;;
			*) echo "> ERROR: Command $1 not recognized"
				Help ;;
		esac
		shift
	done
else
	echo "> ERROR: No commands were found!"
	Help
	exit
fi

###############################################################################
# MAIN END                                                                    #
###############################################################################
